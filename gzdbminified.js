let GZdb;if(window.indexedDB){class GZDB{constructor(name,version){this.name=name;this.version=version;this.Schemas=[];this.db=async()=>{const dbconnect=window.indexedDB.open(name,version),waitSucces=()=>new Promise(resuelve=>dbconnect.onsuccess=e=>resuelve(e.target.result));dbconnect.onupgradeneeded=e=>{const db=e.target.result;this.Schemas.forEach(schema=>{let store = db.createObjectStore(schema[0],schema[2]);schema[1].forEach(e=>{store.createIndex(e.index,e.index,e.condition)})})};let db=await waitSucces();return db;}};openCursor=async(colection,rwx,def)=>{const db=await this.db(),Store=db.transaction(colection,rwx).objectStore(colection),query=Store.openCursor();query.onsuccess=e=>def(e, Store);query.onerror=e=>def({Error:e.target.error.message});};setSchema(name,schema,keyAndIncrement={keyPath:"id",autoIncrement:true}){const Schema=[name,[]],keys=Object.keys(schema);keys.forEach(key=>{if(typeof schema[key]=="object"){Schema[1].push({index:key,condition:schema[key]})}else{Schema[1].push({index:key})}});Schema.push(keyAndIncrement);this.Schemas.push(Schema)};get=async(collection,index,value,length=0)=>{let elements=[],contador=1;length=typeof length=="number"?length:0;const waitForSucces=()=>new Promise(resolve=>{this.openCursor(collection,"readonly",e=>{let result=e.target.result;if(result==null){elements=elements.length>0?elements:false;resolve(elements);return;}if(result.value[index]==value)if(length==0){elements.push(result.value)}else if(length>=contador){contador++;elements.push(result.value);}result.continue();})});return await waitForSucces();};getAll=async(colection)=>{let result=[],waitForSucces =()=>new Promise(async resolve=>{await this.openCursor(colection,"readonly",ev=>{const cursor=ev.target.result;if(cursor){let values=cursor.value;values["key"]=cursor.key;result=result.concat(values);cursor.continue();}else{if(result.length<=0){resolve({404:"Nothing to show"})}resolve(result);}})});return await waitForSucces();};set=async(a,datos)=>{let db=await this.db();const e=db.transaction(a,'readwrite'),store=e.objectStore(a),waitStatus=()=>new Promise((r,x)=>{e.onerror=e=>x({Error:e.target.error.message,code:e.target.error.code});e.oncomplete=e=>r(true)});if(Array.isArray(datos)){datos.forEach(data=>store.add(data))}else{store.add(datos)};return await waitStatus()};Update=async(colection,index,valuekey,data)=>{const waitForSucces=()=>new Promise(async resolve=>{await this.openCursor(colection,"readwrite",ev=>{const cursor=ev.target.result,UpdateData=cursor.value;if(cursor){if(cursor.value[index]==valuekey){for(let i in data){if(UpdateData[i]){UpdateData[i]=data[i];}}const request=cursor.update(UpdateData);request.onsuccess=e=>{resolve(true)}}else{cursor.continue()}}else{resolve({404:"Nothing to show"})}})});return await waitForSucces()};Delete=async(collection,index,value,length=1)=>{let contador=1;length=typeof length=="number"?length:1;const waitForSucces=()=>new Promise(resolve=>{this.openCursor(collection,"readwrite",e=>{let result=e.target.result;if(result==null){resolve(`${contador-1} elements delete`);return};if(result.value[index]==value)if(length==0){contador++;result.delete();}else if(length>=contador){contador++;result.delete();};result.continue()})});return await waitForSucces()};DeleteDB=async()=>{const deletedb=()=>new Promise(resolve=>indexedDB.deleteDatabase(this.name).onsuccess=e=>resolve(true,e));return await deletedb()}};GZdb=GZDB}